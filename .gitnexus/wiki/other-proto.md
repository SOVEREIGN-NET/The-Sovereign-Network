# Other — proto

# Documentation for the **Other — proto** Module

## Overview

The **Other — proto** module defines the protocol buffers (protobuf) for the challenge generation system used in the ZHTP (Zero-Hour Token Protocol). This module is responsible for specifying the data structures and types required for clients to generate and submit proofs in response to challenges issued by a server. The primary focus is on defining the types of proofs, client identities, challenge tokens, and policies that govern the proof generation process.

## Purpose

The main purpose of this module is to facilitate secure and efficient challenge-response interactions between clients and servers. It allows clients to prove their identity and computational effort in a verifiable manner, ensuring that the challenges are met according to specified policies.

## Key Components

### 1. ProofType Enum

The `ProofType` enum defines the types of proofs that can be generated by clients. Each proof type has a specific computational requirement and multiplier that indicates its complexity:

- **HASH**: A simple hash-based proof that requires the hash of the challenge concatenated with a nonce to meet a difficulty target.
- **MERKLE**: A proof based on a Merkle tree, which requires building a partial tree to validate the proof.
- **SIGNATURE**: A proof that involves signing the challenge with a public key, typically using ECDSA or EdDSA.

### 2. ClientIdentity Message

The `ClientIdentity` message encapsulates the identity of the client submitting the proof. It includes:

- `did`: The Decentralized Identifier (DID) of the client.
- `public_key`: The public key used for signature verification, applicable only when the `SIGNATURE` proof type is used.

### 3. Policy Message

The `Policy` message defines the rules governing proof generation and validation. Key fields include:

- `proof_type`: Specifies the required proof type.
- `difficulty`: Indicates the difficulty target, which varies based on the proof type.
- `time_limit_secs`: The maximum time allowed for proof completion.
- `max_attempts`: The maximum number of proof attempts allowed per client per epoch.
- `challenge_cost`: The cost in tokens to claim a challenge.

### 4. ChallengeToken Message

The `ChallengeToken` message is issued to clients and contains essential information for proof generation:

- `challenge_nonce`: A unique nonce generated using a cryptographically secure random number generator (CSPRNG).
- `task_id`: A unique identifier linking the receipt to the original challenge.
- `policy`: The challenge policy that dictates how the proof should be generated.
- `expires_at`: The expiration timestamp for the challenge.
- `issuer_did`: The DID of the server issuing the challenge.
- `signature`: A signature over the canonical bytes of the challenge token.

### 5. SignedChallenge Message

The `SignedChallenge` message wraps the `ChallengeToken` and may include additional metadata for transmission.

### 6. GenerateChallengeRequest and GenerateChallengeResponse Messages

These messages facilitate the request and response cycle for generating new challenges:

- **GenerateChallengeRequest**: Contains the client's identity, preferred proof type, and acceptable proof types.
- **GenerateChallengeResponse**: Returns the generated `SignedChallenge`, server time for synchronization, and an estimated time to solve the challenge.

## Execution Flow

Currently, there are no internal or outgoing calls detected within this module, nor are there any execution flows. The module serves primarily as a data structure definition for protobuf serialization and deserialization.

## Integration with the Codebase

This module is designed to be integrated with the broader ZHTP system, where it interacts with components responsible for challenge issuance and proof validation. The server will utilize the `GenerateChallengeRequest` to create challenges based on client requests, and clients will use the `ChallengeToken` to submit their proofs.

### Example Usage

Here’s a brief example of how a client might use the protobuf definitions to request a challenge:

```python
from zhtp.pouw import GenerateChallengeRequest, ClientIdentity, ProofType

# Create a client identity
client_identity = ClientIdentity(did="client_did", public_key=b"public_key_bytes")

# Create a challenge request
challenge_request = GenerateChallengeRequest(
    client_identity=client_identity,
    preferred_proof_type=ProofType.HASH,
    acceptable_proof_types=[ProofType.HASH, ProofType.MERKLE]
)

# Send the request to the server (implementation of sending is not shown)
```

## Conclusion

The **Other — proto** module is a critical component of the ZHTP framework, providing the necessary data structures for challenge generation and proof submission. Understanding its components and how they interact is essential for developers looking to contribute to or extend the functionality of the ZHTP system.